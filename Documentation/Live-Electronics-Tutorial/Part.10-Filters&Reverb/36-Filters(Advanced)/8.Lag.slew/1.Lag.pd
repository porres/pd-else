#N canvas 229 48 1167 839 12;
#X declare -path else;
#X obj 538 232 setdsp~;
#X obj 878 28 declare -path else;
#X obj 291 280 graph~ 10000 3 0 1 200 140 #dfdfdf 0 1;
#X obj 291 168 pulse~ 4;
#X obj 689 452 pulse~ 4;
#X obj 906 659 graph~ 10000 3 -0.025 1.025 200 140;
#X obj 986 457 v delta;
#X floatatom 721 176 5 10 125 0 - - - 0;
#X text 763 176 ms;
#X floatatom 383 199 4 0 0 0 - - - 0;
#X obj 383 173 expr 1000./$f1;
#X floatatom 383 147 5 10 125 0 - \$0-ms - 0;
#X text 422 146 ms;
#X obj 405 546 v a;
#X obj 291 238 lop~;
#X text 415 200 hz;
#X obj 383 224 hz2rad;
#X obj 383 250 v k;
#X obj 61 238 fexpr~ $x * k + (1 - k) * $y;
#X obj 61 280 graph~ 10000 3 0 1 200 140 #dfdfdf 0 1;
#X obj 312 662 graph~ 10000 3 0 1 200 140 #dfdfdf 0 1;
#X obj 82 558 pulse~ 4;
#X floatatom 312 550 5 10 125 0 - \$0-ms - 0;
#X text 351 550 ms;
#X obj 82 662 graph~ 10000 3 0 1 200 140 #dfdfdf 0 1;
#X obj 312 577 expr a = exp(log(0.001) / ($f1 * sr_khz));
#X floatatom 721 326 5 10 125 0 - - - 0;
#X text 763 326 ms;
#X text 30 13 A 'lag filter' is a non linear ramp to smoothen signal changes and is implemented with a one pole filter \, which is what's inside the [lag~] object from ELSE (and also in other ELSE objects like [decay~] and [adsr~]). But first let's use [lop~]! We want a lag time in ms \, so convert it to cutoff frequency. Below we have [pulse~] at 4 hz \, which alternates between 0 and 1 at double the rate (so 8 hz). The period of 8 hz is 125 ms \, so we use it as the lag time. The [lop~] filter was explained in detail and it was also shown how to implement it with [rpole~] and [fexpr~]. Below we also present the [fexpr~] version \, whose coefficient is the cutoff frequency in radians per sample., f 83;
#X obj 524 167 initmess \; \$0-ms 125;
#X obj 689 612 lag2~;
#X obj 689 659 graph~ 10000 3 -0.025 1.025 200 140;
#X obj 82 616 lag~;
#X obj 705 554 r f_up;
#X obj 721 585 r f_down;
#X obj 917 457 v a_down;
#X obj 735 353 s f_down;
#X obj 721 381 expr a_down = exp(log(0.001) / ($f1 * sr_khz));
#X obj 721 234 expr a_up = exp(log(0.001) / ($f1 * sr_khz));
#X obj 736 205 s f_up;
#X obj 860 457 v a_up;
#X obj 706 497 fexpr~ delta = $y2 - $x \; $x + if(delta < 0 \, a_up * delta \, a_down * delta);
#X text 706 65 The [lag2~] has a distinct time for up and down lag. Below we can see how to implement that with [fexpr~]., f 48;
#X text 827 129 As for the formula coefficient \, you may realize it is quite similar to the formula that converts 'T60' to filter coefficient from [comb.filt~] presented before., f 36;
#X text 831 291 The input time is the lag time in ms for how long it takes for the signal to converge to within 0.01% of the target value., f 39;
#X obj 473 546 sr~ -khz sr_khz;
#X text 47 437 Let's look at [lag~] and its formula now \, which is a bit different. The filter coefficient is calculated from a period input in 'ms' and is multiplied by a difference between the filter's last output and its input. Mathematically this is equivalent to the formula above if "a = 1-k" (but you need to be math savyy to get that) - the only difference is how the coefficient is derived from the frequency input and the difference is minor., f 78;
#X obj 312 617 fexpr~ $x + a * ($y - $x);
#X obj 721 146 initmess 125;
#X obj 721 296 initmess 25;
#X connect 3 0 14 0;
#X connect 3 0 18 0;
#X connect 4 0 30 0;
#X connect 4 0 41 0;
#X connect 7 0 38 0;
#X connect 7 0 39 0;
#X connect 9 0 14 1;
#X connect 9 0 16 0;
#X connect 10 0 9 0;
#X connect 11 0 10 0;
#X connect 14 0 2 0;
#X connect 16 0 17 0;
#X connect 18 0 19 0;
#X connect 21 0 32 0;
#X connect 21 0 47 0;
#X connect 22 0 25 0;
#X connect 22 0 32 1;
#X connect 26 0 36 0;
#X connect 26 0 37 0;
#X connect 30 0 31 0;
#X connect 32 0 24 0;
#X connect 33 0 30 1;
#X connect 34 0 30 2;
#X connect 41 1 5 0;
#X connect 47 0 20 0;
#X connect 48 0 7 0;
#X connect 49 0 26 0;
