#N canvas 292 38 920 760 12;
#X declare -path else;
#X obj 85 607 lop~;
#X obj 94 183 hsl 128 15 20 7050 1 1 empty set-Hz empty -2 -8 0 10 #b8b8b8 #000000 #000000 6970 1;
#X obj 91 342 clip 0 1;
#X obj 103 239 s \$0-hz;
#X obj 110 578 r \$0-hz;
#X floatatom 91 206 6 0 0 0 - - - 0;
#X text 69 206 Hz;
#X floatatom 91 308 0 0 0 0 - - - 0;
#X text 23 305 ________;
#X floatatom 91 374 0 0 0 0 - - - 0;
#X obj 85 548 noise~;
#X obj 254 564 *~;
#X obj 307 567 expr 1 - $f1;
#X obj 268 600 rpole~;
#X obj 254 504 noise~;
#X obj 91 271 hz2rad;
#X text 23 300 radians;
#X text 26 319 sample;
#X obj 91 404 s \$0-radians;
#X obj 85 641 out~;
#X obj 268 658 out~;
#X obj 307 533 r \$0-radians;
#X text 59 467 Compare below:;
#X text 330 591 coefifcient;
#X obj 481 54 noise~;
#X obj 675 26 r \$0-radians;
#X text 469 24 [fexpr~] implementation;
#X obj 537 630 biquad~;
#X obj 537 588 noise~;
#X obj 570 518 trigger float float;
#X obj 570 544 expr 1 - $f1;
#X obj 625 578 pack float 0 float 0 0;
#X obj 570 490 r \$0-radians;
#X obj 537 674 out~;
#X obj 91 151 initmess 500;
#X obj 285 151 declare -path else;
#X obj 481 122 out~;
#X text 28 27 The [lop~] object is a one pole filter. let's see how to implement it. First we convert the frequency from hertz to radians per sample and use this value as a basis for both the pole and input gain coefficients. But since a maximum value for the coefficient is one \, the maximum frequency input is about 7 Khz., f 53;
#X text 182 282 As seen way back \, radians per sample is just another measure for frequencies and tells you how much the phase (in radians) changes from one sample to the next., f 31;
#X listbox 625 616 27 0 0 0 - - - 0;
#X text 458 384 And here's also how to implement it with [biquad~]. We just use the input gain coefficient the coefficient for the first pole. The other coefficients are just zeroed out. Unlike the other options \, you cannot control the filter parameter with a signal input., f 55;
#X text 126 601 could be a signal, f 8;
#X text 336 610 could be a signal, f 8;
#X obj 675 71 v a;
#X obj 719 61 expr 1 - $f1;
#X obj 719 89 v b;
#X obj 481 86 fexpr~ a * $x + b * $y;
#X text 600 128 note you could have a 2nd inlet for signals that controlled the coefficient value, f 31;
#X text 455 201 The filter formula then is: y[n] = a*x[n] + b*y[-1];
#X text 468 223 where 'a' is radians per sample and b is "1 - a";
#X obj 583 287 cnv 15 150 50 empty empty empty 5 12 0 14 #fcc4c4 #404040 0;
#X text 630 297 _____________;
#X text 584 303 H(z) =;
#N canvas 861 140 405 314 H(z) 0;
#X text 35 78 We get:;
#X text 34 43 From: y[n] = a * x[n] + b * y[n-1];
#X text 106 108 Y(z) = a * X(z) + b * Y(z)z^-1;
#X text 108 134 a * X(z) = Y(z) - b * Y(z)z^-1;
#X text 109 158 X(z) = (Y(z) - b * Y(z)z^-1) / a;
#X text 74 183 H(z) = a * Y(z) / Y(z) - b * Y(z)z^-1;
#X text 168 228 _____________;
#X text 122 234 H(z) =;
#X text 211 222 a;
#X text 173 245 1 - b * z^-1;
#X restore 680 338 pd H(z);
#X text 589 263 Transfer function:;
#X text 673 291 a;
#X text 635 314 1 - b * z^-1;
#X text 506 338 see how to get there -->;
#X connect 0 0 19 0;
#X connect 1 0 5 0;
#X connect 2 0 9 0;
#X connect 4 0 0 1;
#X connect 5 0 3 0;
#X connect 5 0 15 0;
#X connect 7 0 2 0;
#X connect 9 0 18 0;
#X connect 10 0 0 0;
#X connect 11 0 13 0;
#X connect 12 0 13 1;
#X connect 13 0 20 0;
#X connect 14 0 11 0;
#X connect 15 0 7 0;
#X connect 21 0 11 1;
#X connect 21 0 12 0;
#X connect 24 0 46 0;
#X connect 25 0 43 0;
#X connect 25 0 44 0;
#X connect 27 0 33 0;
#X connect 28 0 27 0;
#X connect 29 0 30 0;
#X connect 29 1 31 2;
#X connect 30 0 31 0;
#X connect 31 0 27 0;
#X connect 31 0 39 0;
#X connect 32 0 29 0;
#X connect 34 0 1 0;
#X connect 44 0 45 0;
#X connect 46 0 36 0;
