#N canvas 300 70 846 549 12;
#X declare -path else;
#X obj 250 235 nbx 8 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 338 233 nbx 8 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 642 23 declare -path else;
#X obj 250 266 vsl 19 162 0 100 0 0 empty empty empty 0 -9 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 250 161 adc~ 1;
#X obj 250 207 env~ 8192;
#X obj 50 231 *~;
#X obj 159 282 meter~;
#X obj 50 191 bl.saw~ 50;
#X obj 50 275 out~;
#X obj 359 376 sigmund~;
#X text 291 288 Another object that reports amplitude analysis like [env~] is [sigmund~] \, which we'll see next., f 20;
#X text 25 21 We've already seen the [env~] object from Pd Vanilla and [rms~] from ELSE that is based on it. The difference is just the output scale. They output RMS amplitude from an audio analysis. This is also known as "envelope following" and we can use this analysis to control parameters in our patches. Another object we can use is [mov.avg~]. Here we use it to control the output level., f 58;
#X obj 159 228 mov.rms~ -lin 4096, f 9;
#X obj 338 206 rms~ -lin;
#X obj 503 234 abs~;
#X obj 603 166 else/play.file~ loop.wav 1 1;
#X obj 503 315 meter~;
#X obj 503 277 lag2~ 10 100;
#X text 476 59 We can also use [abs~] to get the absolute value of a signal and into a lowpass filter. Such a filter can have different coefficients for rising or falling signals - that is the attack or release phase. Such a filter can be [slop~] or [lag2~]., f 45;
#X obj 604 277 follow~ -f 10 100;
#X obj 604 317 vsl 25 120 0 1 0 0 empty empty empty 0 -9 0 12 #dfdfdf #000000 #000000 0 1;
#X text 657 333 The [follow~] object from ELSE is like [abs~] and [lag2~] \, but it can also output floats., f 20;
#X text 136 487 VU metering \, as done with the [meter~] object above \, is nothing but envelope following. Let's break it down in here:;
#X text 88 380 [meter~];
#N canvas 516 145 667 617 VU-metering 0;
#X obj 60 234 env~ 1024;
#X obj 152 203 abs~;
#X obj 152 268 snapshot~;
#X obj 152 301 rmstodb;
#X obj 152 233 slop~ 0 0 0 0 1e+09;
#X obj 60 268 t f b;
#X obj 60 309 - 100;
#X obj 152 326 - 100;
#X obj 230 200 expr 1000 / $f1;
#X obj 230 169 else/initmess 500;
#X obj 60 119 else/play.file~ loop.wav 1 1;
#X obj 139 379 vu 19 200 empty empty -1 -10 0 12 #404040 #000000 1 0;
#X obj 350 296 t f b;
#X obj 442 194 else/play.file~ loop.wav 1 1;
#X obj 411 379 vu 19 200 empty empty -1 -10 0 12 #404040 #000000 1 0;
#X obj 350 262 rms~ 1024;
#X text 38 22 Below we have an envelope follower checking the peak amplitude of a sound input. The attack must be immediate \, so the attack is '0' ms. The release is set to 500 ms. This is fully Vanilla., f 49;
#X obj 442 262 follow~ -f 0 500;
#X obj 424 344 lin2db;
#X obj 424 314 f;
#X text 414 28 The version below is with ELSE objects. In both \, we use the output of either [env~] or [rms~] to collect the peak amplitude envelope - which happens at every 11 ms or so at 48 Khz., f 30;
#X connect 0 0 5 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 3 0 7 0;
#X connect 4 0 2 0;
#X connect 5 0 6 0;
#X connect 5 1 2 0;
#X connect 6 0 11 0;
#X connect 7 0 11 1;
#X connect 8 0 4 3;
#X connect 9 0 8 0;
#X connect 10 0 0 0;
#X connect 10 0 1 0;
#X connect 12 0 14 0;
#X connect 12 1 19 0;
#X connect 13 0 15 0;
#X connect 13 0 17 0;
#X connect 15 0 12 0;
#X connect 17 0 19 1;
#X connect 18 0 14 1;
#X connect 19 0 18 0;
#X restore 585 495 pd VU-metering;
#X obj 626 206 out~;
#X connect 0 0 3 0;
#X connect 4 0 5 0;
#X connect 4 0 13 0;
#X connect 4 0 14 0;
#X connect 5 0 0 0;
#X connect 6 0 9 0;
#X connect 8 0 6 0;
#X connect 13 0 6 1;
#X connect 13 0 7 0;
#X connect 14 0 1 0;
#X connect 15 0 18 0;
#X connect 16 0 15 0;
#X connect 16 0 20 0;
#X connect 16 0 26 0;
#X connect 18 0 17 0;
#X connect 20 0 21 0;
